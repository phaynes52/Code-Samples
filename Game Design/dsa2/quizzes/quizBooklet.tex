\documentclass[10pt]{article}
\usepackage[top=1in,bottom=1in,left=0.75in,right=0.75in,centering]{geometry}
\usepackage{fancyhdr}
\usepackage{epsfig}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{palatino}
\usepackage{wrapfig}
\usepackage{lastpage}
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{ifthen}
\usepackage[table]{xcolor}
\usepackage{graphicx,type1cm,eso-pic,color}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{array}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{listings}
\lstset{
	language=Java
}
\usepackage{subcaption}

\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{N}{@{}m{0 pt}@{}}

\makeatletter
% Reinsert missing \algbackskip
\def\algbackskip{\hskip-\ALG@thistlm}
\makeatother

\def\course{CS 2501: DSA2}
\def\exam{Quiz Booklet}
\def\semester{Spring 2020}

\newboolean{solution}
\setboolean{solution}{false}

% add watermark if it's a solution exam
% see http://jeanmartina.blogspot.com/2008/07/latex-goodie-how-to-watermark-things-in.html
\makeatletter
\AddToShipoutPicture{%
\setlength{\@tempdimb}{.5\paperwidth}%
\setlength{\@tempdimc}{.5\paperheight}%
\setlength{\unitlength}{1pt}%
\put(\strip@pt\@tempdimb,\strip@pt\@tempdimc){%
\ifthenelse{\boolean{solution}}{
\makebox(0,0){\rotatebox{45}{\textcolor[gray]{0.95}%
{\fontsize{5cm}{3cm}\selectfont{\textsf{Solution}}}}}%
}{}
}}
\makeatother

\pagestyle{fancy}

\fancyhf{}
\lhead{\course\ \exam, \semester}
\chead{Page \thepage\ of \pageref{LastPage}}
\rhead{UVa userid: \hspace{0.75in}}
\cfoot{}

\setlength{\headheight}{14.5pt}

\newenvironment{itemlist}{
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}}
{\end{itemize}}

\newenvironment{numlist}{
\begin{enumerate}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}}
{\end{enumerate}}

\newcounter{pagenum}
\setcounter{pagenum}{2}
\newcommand{\pageheader}[1]{
\clearpage\vspace*{-0.4in}\noindent{\large\bf{{#1}}}
\addtocounter{pagenum}{1}
\cfoot{}
}

\newcounter{quesnum}
\setcounter{quesnum}{1}
\newcommand{\question}[2][??]{
\begin{list}{\labelitemi}{\leftmargin=2em}
\item [\arabic{quesnum}.] {[}{#1} points{]} {#2}
\end{list}
\addtocounter{quesnum}{1}
}

\definecolor{red}{rgb}{1.0,0.0,0.0}
\newcommand{\answer}[2][??]{
%\begin{tabular}{p{0.25in}p{6in}}

\ifthenelse{\boolean{solution}}{
\color{red} #2 \color{black}}
{\vspace*{#1} }
%\end{tabular}
}

\begin{document}

\section*{\course\ \exam}

\vspace{0.1in}

\vspace{0.35in}

\noindent This booklet contains question pools for the quizzes for this course. You should use this resource to study potential questions that will be asked on the quizzes.

\vspace{12pt}

\noindent DO NOT write on this booklet, as we may use it multiple times in future weeks.

\vspace{12pt}

\noindent There are \pageref{LastPage} pages to this quiz booklet.

\vspace{12pt}



\vspace{0.15in}

\begin{quotation}
\begin{centering}
%\noindent {\em In theory, there is no difference between theory and practice.\\But, in practice, there is.\\}
%\noindent {\em The Tao that is seen \\ Is not the true Tao, \\ until You bring fresh toner.\\}
\noindent {\em A crash reduces\\Your expensive computer\\To a simple stone.\\}
%\noindent {\em Three things are certain:\\Death, taxes, and lost data.\\Guess which has occurred.\\}
%\noindent {\em You step in the stream,\\But the water has moved on.\\This page is not here.\\}
%\noindent {\em Serious error.\\All shortcuts have disappeared.\\Screen. Mind. Both are blank.\\}
\end{centering}
\end{quotation}


%----------------------------------------------------------------------

\pageheader{Graphs - Basic}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Given an undirected graph with $V$ nodes (no loops allowed). What is the maximum number of edges the graph can have?
	\item Given a directed graph with $V$ nodes (no loops allowed). What is the maximum number of edges the graph can have?
	\item Name one advantage and one disadvantage of storing a graph as an adjacency matrix.
	\item Name on advantage and one disadvantage of storing a graph as an adjacency list.
	\item Describe one way we can handle storing costs of graph edges. Make sure to answer for an adjacency list AND an adjacency matrix.
	\item Does breadth-first search always find the shortest path between two nodes for an undirected, unweighted graph?
	\item Which has better time-complexity? BFS or DFS?
	\item Which has better space-complexity? BFS or DFS?
	\item What is the run-time of BFS? Explain your answer.
	\item What is the run-time of DFS? Explain your answer.
	\item Briefly describe how you might use DFS to count the number of disconnected components (disconnected sub-graphs) in a graph.
	\item What is the run-time of topological sort?
	\item What is the run-time of Dijkstra's Algorithm?
	\item Dijkstra's Algorithm may not work if given negative cost edges. Provide a counter-example to illustrate this.
\end{enumerate}

\vspace{0.5in}

\textbf{Coding Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Psuedo-code a method that performs a breadth-first search on a graph. Assume each node stores a number num. Print out each num as you visit each node.
	\item Psuedo-code a method that performs a depth-first search on a graph. Assume each node stores a number num. Print out each num as you visit each node.
	\item Pseudo-code the topological sort algorithm.
	\item Psuedo-code Dijkstra's Algorithm.
\end{enumerate}


\newif\ifcomment
\commentfalse
\ifcomment

\fi

%----------------------------------------------------------------------

\pageheader{Graphs - Advanced}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Given a flow network and current flow values, produce the residual graph. A network to use will be drawn on the board.
	\item When discussing flow networks, what is backflow? Explain why it is necessary.
	\item Describe how the Ford-Fulkerson algorithm uses depth-first search. What purpose does it serve? Why not use breadth-first search?
	\item What is the run-time of the Ford-Fulkerson Algorithm? Explain your answer.
	\item Define the following terms regarding flow networks: Cut, capacity of a cut, and net-flow of a cut.
	\item What does the max-flow, min-cut theorem state? What does this say about algorithms for the two problems?
	\item What is a reduction? Why is it useful when comparing algorithms?
	\item Describe how you would solve for the maximum-flow of a network that has multiple sources and multiple sinks.
\end{enumerate}

\vspace{0.5in}

\textbf{Coding Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Psuedo-code the Ford-Fulkerson Algorithm.
	\item Prove the flow-value lemma: The the net-flow across any cut is always equal to the flow $f$
	\item Psuedo-code an algorithm that solves the Bipartite matching problem.
\end{enumerate}


%----------------------------------------------------------------------

\pageheader{Find-Union: Prims and Kruskals}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Give an example of a graph (with edge costs) that has more than one minimum spanning tree.
	\item How many edges does a minimum spanning tree have as a function of the original connected graph $G=(V,E)$? Explain why.
	\item True or False: If the edge weights of a graph are all unique, then the minimum spanning tree is unique as well. Explain your answer.
	\item Given a graph (drawn on the board) and a starting node, step through Prim's algorithm. Draw the MST and list the order in which the nodes are added to the tree.
	\item What do we mean when we say that the Minimum Spanning Tree problem has optimal substructure?
	\item What is the runtime of Prim's algorithm?
	\item What is the runtime of Kruskal's algorithm?
	\item Describe how the findSet(int i) method works for a find-union data structure? What is the runtime?
	\item Describe how the union(int i, int j) method works for a find-union data structure. What is the runtime?
	\item When implementing a find-union structure, what is union by rank? Why is it useful?
	\item When implementing a find-union structure, what is path compression? Why is it useful?

\end{enumerate}

\vspace{0.5in}

\textbf{Coding Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Write pseudo-code for Prim's algorithm
	\item Write pseudo-code for Kruskal's algorithm
	\item Pseudo-code the findSet(int i) method of a find-union structure.
	\item Pseudo-code the union(int i, int j) method of a find-union structure.

\end{enumerate}

%----------------------------------------------------------------------

\pageheader{Greedy Algorithms: Basic}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item What is a \emph{feasible solution}, when discussing optimization problems?
	\item What is an \emph{objective function} when discussing optimization problems?
	\item Briefly describe why greedy algorithms are typically easy to implement.
	\item What was the runtime of the greedy change making algorithm from class? Make sure to explain your variables and explain your answer.
	\item When describing greedy algorithms, what is \emph{optimal substructure}? Why is it useful?
	\item Describe the greedy algorithm from class for solving the \emph{continuous knapsack problem}.
	\item What is the runtime of the greedy algorithm for the \emph{continuous knapsack problem}.
	\item Describe the greedy algorithm we used in class for the \emph{interval selection problem}.
	\item What was the runtime of the \emph{interval selection} greedy algorithm from class? Explain your answer.
\end{enumerate}

\vspace{0.5in}

\textbf{Coding Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Pseudo-code the \emph{making change} algorithm from class.
	\item Pseudo-code the \emph{continuous knapsack} algorithm from class.
	\item Pseudo-code the \emph{interval selection} algorithm from class.
\end{enumerate}

%----------------------------------------------------------------------

\pageheader{Greedy Algorithms: Advanced}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Consider a brute-force solution to the \emph{making change} problem. What would the runtime of this algorithm be?
	\item Given a coin-set of 1,6,10; provide a counter-example showing that the greedy algorithm no longer works.
	\item Consider the \emph{discrete knapsack problem}. For this problem, you must take the entire item and its full cost and weight. Provide a counter-example to show that the greedy selection rule for continuous knapsack won't work for this variant of the problem.
	\item Consider a greedy algorithm for \emph{interval selection} that selects the interval with the fewest conflicts (i.e., the fewest other intervals that are overlapping with this one). Provide a counter-example showing that this will not always produce the optimal solution.
\end{enumerate}

\vspace{0.5in}

\textbf{Coding/Proof Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Argue the the \emph{making change} problem has \emph{optimal substructure}.
	\item Argue that \emph{making change} has the \emph{greedy choice property} (i.e., the largest coin must be in the optimal solution.). Use 1,5,10,25 as your coin set and only argue for change amounts of 25 or higher.
	\item Prove by induction that the \emph{interval selection} greedy algorithm from class is optimal.
\end{enumerate}


%----------------------------------------------------------------------

\pageheader{Divide and Conquer: Basic}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item In class, we saw a Div. and Conq. algorithm for \emph{closest pair of points} that divided the list of points in half, recursively solved, then checked points across the dividing line before returning a solution. Describe what the runtime of this algorithm (be precise / prove it) and describe why this approach is not ideal.
	\item Once we came up with a more clever algorithm for \emph{closest pair of points}, what was the recurrence relation and runtime of this algorithm? Explain your answer.
	\item Briefly describe how we more cleverly combined solutions to subproblems of the \emph{closest pair of points} problem.
	\item Describe the solution we produced for the \emph{trominoes} problem.
	\item What was the runtime of our solution to the \emph{trominoes} problem. Explain your answer.
\end{enumerate}

\vspace{0.5in}

\textbf{Coding/Proof Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Directly solve the following recurrence that we did in class: $T(n) = 2T(\frac{n}{2})+n$.
	\item Use the substitution method to solve the following recurrence that we did in class: $T(n) = 2T(\frac{n}{2})+n$.
	\item Use the substitution method to solve the following recurrence that we did in class: $T(n) = 2T(\frac{n}{2})+1$.
\end{enumerate}



%----------------------------------------------------------------------

\pageheader{Divide and Conquer: Advanced}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Strassen's matrix multiplication algorithm is a clever way to reduce the runtime of this problem. What is the recurrence relation for the naive divide-and-conquer and also for Strassen's approach? Use the Master Theorem to present the runtimes of these two approaches.
	\item When discussing the Master Theorem, what is the intuitive explanation of case 1? If your recurrence is $T(n)=aT(\frac{n}{b})+f(n)$, then let $k=log_b(a)$. Case 1 states that if $f(n) \in O(n^{k-\epsilon}$ for some positive $\epsilon$, then $T(n) \in \Theta(n^k)$.
	\item When discussing the Master Theorem, what is intuitive explanation of case 2? Remember that case 2 states that if $f(n) \in \Theta(n^k)$ then $T(n) \in \Theta(f(n)log(n)) = \Theta(n^klog(n))$.
	\item When discussing the Master Theorem, what is the purpose of the \emph{regularity condition} (part of case 3). It states that $af(\frac{n}{b}) \leq cf(n)$ for some $c<1$ and sufficiently large $n$.
\end{enumerate}

\vspace{0.5in}

\textbf{Coding/Proof Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Pseudo-code a Div. and Conq. algorithm that finds the smallest and largest index of a given integer in a sorted array. If the element is not in the array, report that as well. State the runtime of your algorithm. Notice, that the element might be in the array multiple times.
	\item Pseudo-code a Div. and Conq. algorithm that finds the largest and smallest elements in an array (not sorted). What is the runtime of your algorithm? Is it better than doing a linear scan?
	\item Write a recursive divide and conquer algorithm that takes an unsorted array and turns it into a min-heap. You may assume you have access to \emph{percolateDown(node)}.
\end{enumerate}

%----------------------------------------------------------------------

\pageheader{Dynamic Programming: Basic}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Dynamic programming often works when problems have \emph{overlapping subproblems}. What exactly does this mean? Provide an example from class.
	\item When using dynamic programming, what is \emph{memoization}? Describe why it is useful for solving problems.
	\item When using \emph{memoization}, why do we typically use an array instead of some other data structure?
	\item When solving the \emph{discrete knapasack problem}, what was the recurrence for our recursive case for solving this problem in terms of smaller subproblems?
	\item When solving the \emph{discrete knapsack problem}, what was the size of the array we used to store solutions? Briefly describe why.
	\item When solving the \emph{weighted interval scheduling} problem, what was the function $p(j)$. Briefly describe why it is useful.
	\item When solving the \emph{weighted interval scheduling} problem, what was the recursive function we used for our dynamic programming solution? Briefly explain the intuition behind the formula.
	\item What is the runtime of our dynamic programming solution to \emph{weighted interval scheduling}? Briefly explain.
\end{enumerate}

\vspace{0.5in}

\textbf{Coding/Proof Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Write psuedo-code for a simple dynamic programming solution to \emph{fib(n)}, a function that returns the nth fibonacci number.
	\item Write a method that given a list of weighted intervals, computes the array $p(j)$ that we need to run the dynamic programming algorithm from class. Your algorithm must be $O(nlog_2(n))$.
	\item Write psudo-code for our solution to the \emph{weighted interval scheduling} problem. You may assume $p(j)$ is already calculated for each interval $j$.
\end{enumerate}
%----------------------------------------------------------------------

%----------------------------------------------------------------------

\pageheader{Dynamic Programming: Advanced}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Briefly describe why our runtime for \emph{discrete knapsack} from class is not actually a polynomial time algorithm.
	\item When solving the \emph{longest common subsequence (LCS)} problem, what was the runtime of a brute-force solution? Briefly describe why.
	\item When solving the \emph{LCS} problem, what was our recursive solution in the case that the last two characters match? Briefly describe the intuition behind this.
	\item When solving the \emph{LCS} problem, what was our recursive solution in the case that the last two characters \textbf{DO NOT} match? Briefly describe the intuition behind this.
	\item When solving the \emph{LCS} problem, what was the size of the array we used to store the subproblems?
	\item When solving the \emph{making change} problem, what was the recursive case when the highest coin was too high for the amount of change to be made? Explain why?
	\item When solving the \emph{making change} problem, what was the recursive case when the highest coin could be used for the given amount of change? Explain why?
\end{enumerate}

\vspace{0.5in}

\textbf{Coding/Proof Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Psuedocode a method that, given an array produced by our \emph{LCS} algorithm, performs backtracking to determine the actual string that is the longest common subsequence.
	\item Psudocode a method that, given an array produced by our dynamic programming algorithm for \emph{making change}, produces the actual coins to use in the solution.
\end{enumerate}
%----------------------------------------------------------------------

\pageheader{Reductions}

\noindent \\
\textbf{Short Answer Questions}

\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Given a problem $A$ and another problem $B$, explain what $A \leq_p B$ means. What about $A \leq_{n^2} B$? In this case, which of the two problems looks harder to solve?
	\item In class we saw both the Independent Set (IS) and Vertex Cover (VC) problems. What does it mean that $IS \leq_p VC$ and $VC \leq_p IS$? Briefly explain why?
	\item Describe the difference between decision problems, verification problems, and function problems.
	\item What is the decision problem version of the \emph{traveling salesperson problem}?
	\item What is the complexity class $P$? Why is this class important?
	\item What is the complexity class $NP$? Why is this class important?
	\item What does it mean for a problem to be \emph{NP-Hard}?
	\item What does it mean for a problem to be \emph{NP-Complete}?
	\item Briefly describe the significance of the \emph{Cook-Levin Theorem}. Make sure to list what the theorem states as well as its significance.
\end{enumerate}

\vspace{0.5in}

\textbf{Coding/Proof Questions}
\begin{enumerate}
	\setlength\itemsep{0.25em}
	\item Give a short informal proof that the runtime a problem's functional version is the same as the runtime of its decision version.
	\item Give a short proof of the following: A problem is verifiable in polynomial time by a deterministic turing machine if and only if it is solvable in polynomial time by a non-deterministic turing machine.
	\item Argue that $P \subseteq NP$
	\item Give an overview of the reduction from \emph{3-SAT} to \emph{Clique} that we saw in class. You do not need to provide every detail of this reduction, but enough that we see you understand the approach.
	\item Give an overview of the reduction from \emph{Clique} to \emph{Vertex Cover} that we saw in class. You do not need to provide every detail of this reduction, but enough that we see you understand the approach.


\end{enumerate}
%----------------------------------------------------------------------

\end{document}
