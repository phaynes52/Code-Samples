\documentclass[12pt]{article}
\usepackage[top=1in,bottom=1in,left=0.75in,right=0.75in,centering]{geometry}
\usepackage{fancyhdr}
\usepackage{epsfig}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{palatino}
\usepackage{wrapfig}
\usepackage{lastpage}
\usepackage{color}
\usepackage{ifthen}
\usepackage[table]{xcolor}
\usepackage{graphicx,type1cm,eso-pic,color}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{wasysym}

\def\course{CS 2501: DSA2}
\def\homework{Greedy - Advanced: Written Problems}
\def\semester{Spring 2020}

\newboolean{solution}
\setboolean{solution}{false}

% add watermark if it's a solution exam
% see http://jeanmartina.blogspot.com/2008/07/latex-goodie-how-to-watermark-things-in.html
\makeatletter
\AddToShipoutPicture{%
\setlength{\@tempdimb}{.5\paperwidth}%
\setlength{\@tempdimc}{.5\paperheight}%
\setlength{\unitlength}{1pt}%
\put(\strip@pt\@tempdimb,\strip@pt\@tempdimc){%
\ifthenelse{\boolean{solution}}{
\makebox(0,0){\rotatebox{45}{\textcolor[gray]{0.95}%
{\fontsize{5cm}{3cm}\selectfont{\textsf{Solution}}}}}%
}{}
}}
\makeatother

\pagestyle{fancy}

\fancyhf{}
\lhead{\course}
\chead{Page \thepage\ of \pageref{LastPage}}
\rhead{\semester}
%\cfoot{\Large (the bubble footer is automatically inserted into this space)}

\setlength{\headheight}{14.5pt}

\newenvironment{itemlist}{
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}}
{\end{itemize}}

\newenvironment{numlist}{
\begin{enumerate}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}}
{\end{enumerate}}

\newcounter{pagenum}
\setcounter{pagenum}{1}
\newcommand{\pageheader}[1]{
\clearpage\vspace*{-0.4in}\noindent{\large\bf{Page \arabic{pagenum}: {#1}}}
\addtocounter{pagenum}{1}
\cfoot{}
}

\newcounter{quesnum}
\setcounter{quesnum}{1}
\newcommand{\question}[2][??]{
\begin{list}{\labelitemi}{\leftmargin=2em}
\item [\arabic{quesnum}.] {} {#2}
\end{list}
\addtocounter{quesnum}{1}
}


\definecolor{red}{rgb}{1.0,0.0,0.0}
\newcommand{\answer}[2][??]{
\ifthenelse{\boolean{solution}}{
\color{red} #2 \color{black}}
{\vspace*{#1}}
}

\definecolor{blue}{rgb}{0.0,0.0,1.0}

\begin{document}

\section*{\homework}

%----------------------------------------------------------------------

\question[2]{
You are given a set of points $P=\{ p_1, p_2, ... , p_n \}$ on the real line (you may assume these are given to you in sorted order). Describe an algorithm that determines the smallest set of unit-length closed intervals that contains all of the given points. For example, the points $\{ 0.9, 1.2, 1.3, 2.1, 3.0 \}$ can be covered by $[ 0.7, 1.7 ]$ and $[ 2.0, 3.0 ]$. State the runtime of your algorithm.
}

%----------------------------------------------------------------------


\question[3]{
Prove that your algorithm always returns the optimal result.
}

\answer[0 in]{
...
}

%----------------------------------------------------------------------


\question[2]{
Consider a situation in which you have $n$ skiers with heights $p_1,p_2,...,p_n$, and $n$ pairs of skis with length $s_1,s_2,...,s_n$. The problem is to assign each person a pair of skis so that the overall difference between the height of a skier and the length of their skis is minimized. More precisely, if $\alpha(i)$ returns the index of the skis assigned to person $p_i$, we want to minimize:

\begin{align*}
\frac{1}{n}\sum_{i=1}^{n}(|p_i - s_{\alpha(i)}|)
\end{align*}

Consider two greedy algorithms that may solve this problem:

\begin{enumerate}
\item Find the skier and skis whose height difference is minimized. Assign those skis to that skier and repeat.
\item Pair the smallest skier with the smallest skis, second smallest skier to second shortest skis, etc. until all pairings are complete.
\end{enumerate}

One of these greedy algorithms is correct. You must do three things: Prove this problem has optimal substructure. Claim which of the two algorithms is correct. Then show the greedy choice property of your chosen algorithm by using an exchange argument.
}

\answer[0.25 in]{
...
}


%----------------------------------------------------------------------

\question[3]{
Let's suppose we want to replicate a single file $f$ over a collection of $n$ servers $S_1,S_2,...,S_n$. Each server has a cost of storing the file. Let $c_i$ be the cost of storing $f$ on server $i$. Let's also stipulate that $c_n=0$ (to guarantee that the file can be stored on at least one server for free).\\
\\
Your problem is to figure what subset of the $n$ servers you should store the file on in order to minimize cost (which we define in more detail now). Suppose the file is stored on a subset of server indices $L \subseteq [1,n]$ and that $n \in L$ ($L$ cannot be empty). More formally, file $f$ is on server $i$ iff $i \in L$. When a user tries to access the file they start from some server $S_j$, and they attempt to access $S_j$, then $S_{j+1}$ etc until they find the file (they will always find $f$ on $S_n$ in the worst case). We say this costs the user:

\begin{align*}
u_j = \left( \min\limits_{k \geq j : k \in L} k \right) - j
\end{align*}

For any particular set $L \subseteq [1,n]$, the total cost is thus:

\begin{align*}
cost(L) = \sum\limits_{i \in L} c_i + \sum\limits_{j \in [1,n]} u_j
\end{align*}

First, provide a brute-force algorithm that solves this problem. What is the run-time and why? Then, provide a better algorithm that solves this problem.
}

\answer[0.25 in]{
...
}

%----------------------------------------------------------------------


\end{document}
